#!/usr/bin/env python3
"""
Agent D — Models Generation Agent

Generates Rust structs, enums, and type aliases from the Torn OpenAPI spec.
Produces all files in crates/torn_models/src/generated/.
"""

import json
import os
import re
from typing import Any, Dict, List, Optional, Set, Tuple


# =============================================================================
# Constants
# =============================================================================

RUST_KEYWORDS = {
    "as", "break", "const", "continue", "crate", "else", "enum", "extern",
    "false", "fn", "for", "if", "impl", "in", "let", "loop", "match", "mod",
    "move", "mut", "pub", "ref", "return", "self", "Self", "static", "struct",
    "super", "trait", "true", "type", "unsafe", "use", "where", "while",
    "async", "await", "dyn", "abstract", "become", "box", "do", "final",
    "macro", "override", "priv", "typeof", "unsized", "virtual", "yield"
}

GENERATED_HEADER = """\
// =============================================================================
// AUTO-GENERATED — DO NOT EDIT
// =============================================================================
// This module is generated by the regen pipeline (scripts/regen.py).
// Any manual changes will be overwritten on the next regeneration.
//
// To fix issues in generated code, modify the generator configuration or add
// a deterministic patch step. See GENERATED_POLICY.md.
// =============================================================================
"""


# =============================================================================
# Type Mapping
# =============================================================================

def map_openapi_type_to_rust(
    schema: dict,
    type_name: Optional[str] = None,
    parent_name: Optional[str] = None
) -> str:
    """
    Map OpenAPI type to Rust type.

    Args:
        schema: OpenAPI schema object
        type_name: Name of the type being mapped (for enums/refs)
        parent_name: Parent struct name (for nested types)

    Returns:
        Rust type string
    """
    # Handle $ref
    if "$ref" in schema:
        ref_name = schema["$ref"].split("/")[-1]
        return to_rust_type_name(ref_name)

    # Handle enum
    if "enum" in schema:
        # If we have a type_name, this is a named enum - return the type name
        if type_name:
            return to_rust_type_name(type_name)
        # Otherwise it's inline - caller should handle this
        return "String"  # Fallback

    schema_type = schema.get("type")
    schema_format = schema.get("format")

    # String types
    if schema_type == "string":
        if schema_format == "date-time":
            return "String"  # TODO: use chrono::DateTime later
        elif schema_format == "date":
            return "String"  # TODO: use chrono::NaiveDate later
        return "String"

    # Integer types
    if schema_type == "integer":
        if schema_format == "int32":
            return "i32"
        elif schema_format == "int64":
            return "i64"
        return "i64"  # Default to i64

    # Number types
    if schema_type == "number":
        if schema_format == "float":
            return "f32"
        elif schema_format == "double":
            return "f64"
        return "f64"  # Default to f64

    # Boolean
    if schema_type == "boolean":
        return "bool"

    # Array
    if schema_type == "array":
        items = schema.get("items", {})
        item_type = map_openapi_type_to_rust(items, parent_name=parent_name)
        return f"Vec<{item_type}>"

    # Object with additionalProperties (map/dict)
    if schema_type == "object":
        additional_props = schema.get("additionalProperties")
        if additional_props and not schema.get("properties"):
            # It's a HashMap
            if isinstance(additional_props, dict):
                value_type = map_openapi_type_to_rust(additional_props, parent_name=parent_name)
            else:
                value_type = "serde_json::Value"
            return f"std::collections::HashMap<String, {value_type}>"
        # Has properties - should be a named struct
        if parent_name and type_name:
            return to_rust_type_name(f"{parent_name}_{type_name}")

    # Composition types (allOf, oneOf, anyOf) - caller should handle
    if "allOf" in schema or "oneOf" in schema or "anyOf" in schema:
        if type_name:
            return to_rust_type_name(type_name)

    # Fallback for unknown types
    return "serde_json::Value"


# =============================================================================
# Naming Utilities
# =============================================================================

def to_snake_case(name: str) -> str:
    """Convert a name to snake_case."""
    # Handle acronyms and camelCase
    s1 = re.sub('(.)([A-Z][a-z]+)', r'\1_\2', name)
    s2 = re.sub('([a-z0-9])([A-Z])', r'\1_\2', s1)
    result = s2.lower()

    # Handle special characters
    result = re.sub(r'[^a-z0-9_]', '_', result)
    result = re.sub(r'_+', '_', result)  # Remove duplicate underscores
    result = result.strip('_')

    # Handle Rust keywords
    if result in RUST_KEYWORDS:
        result = f"{result}_"

    return result


def to_rust_type_name(name: str) -> str:
    """Convert a schema name to a Rust type name (PascalCase)."""
    # Remove special characters but preserve case structure
    name = re.sub(r'[^a-zA-Z0-9_]', '', name)

    # If already PascalCase, return as-is
    if name and name[0].isupper():
        return name

    # Convert from snake_case or camelCase to PascalCase
    parts = re.split(r'[_\s]+', name)
    return ''.join(word.capitalize() for word in parts if word)


def to_rust_enum_variant(value: str) -> str:
    """Convert an enum value to a Rust enum variant name."""
    # Handle numeric strings
    if value.isdigit():
        return f"Value{value}"

    # Handle special cases
    if value.upper() == value and len(value) <= 4:
        # Likely an acronym like "ASC", "DESC", "GET"
        return value.capitalize() if len(value) <= 3 else to_rust_type_name(value)

    # Convert to PascalCase
    result = to_rust_type_name(value)

    # If starts with number, prefix with underscore
    if result and result[0].isdigit():
        result = f"Value{result}"

    return result


def sanitize_field_name(name: str) -> str:
    """Sanitize a JSON field name for use as a Rust field name."""
    snake = to_snake_case(name)

    # Handle fields starting with numbers
    if snake and snake[0].isdigit():
        snake = f"field_{snake}"

    return snake


# =============================================================================
# Code Generation
# =============================================================================

class RustCodeGenerator:
    """Generates Rust code from OpenAPI schemas."""

    def __init__(self, schema_map: dict, spec_map: dict):
        self.schema_map = schema_map
        self.spec_map = spec_map
        self.generated_types: Set[str] = set()
        self.nested_type_definitions: List[str] = []

    def generate_all(self) -> Dict[str, str]:
        """
        Generate all Rust modules.

        Returns:
            Dict mapping module name to file content
        """
        # Organize schemas by tag
        tag_schemas = self._organize_schemas_by_tag()

        # Generate module files
        modules = {}
        for tag, schemas in sorted(tag_schemas.items()):
            module_content = self._generate_module(tag, schemas)
            modules[f"{tag}.rs"] = module_content

        # Generate mod.rs
        modules["mod.rs"] = self._generate_mod_rs(list(modules.keys()))

        return modules

    def _organize_schemas_by_tag(self) -> Dict[str, List[str]]:
        """Organize schemas by their associated API tag."""
        tag_schemas: Dict[str, List[str]] = {}
        schema_to_tags: Dict[str, Set[str]] = {}
        referenced_schemas: Set[str] = set()

        # Build schema→tags mapping from spec_map (for response schemas)
        response_schemas = set()
        for tag in sorted(self.spec_map.keys()):
            endpoints = self.spec_map[tag]
            for endpoint in endpoints:
                schema_ref = endpoint.get("responseSchemaRef")
                if schema_ref:
                    schema_name = schema_ref.split("/")[-1]
                    response_schemas.add(schema_name)
                    schema_to_tags.setdefault(schema_name, set()).add(tag)

        # Find all schemas referenced by response schemas (recursively)
        def collect_references(schema_name: str, parent_tags: Set[str]):
            """Recursively collect all referenced schemas."""
            if schema_name in referenced_schemas:
                return
            if schema_name not in self.schema_map:
                return

            referenced_schemas.add(schema_name)

            # Add parent tags to this schema
            for tag in parent_tags:
                schema_to_tags.setdefault(schema_name, set()).add(tag)

            schema = self.schema_map[schema_name]

            # Check for $ref in various places
            self._collect_refs_recursive(schema, parent_tags)

        def _collect_refs_from_schema(schema: dict, parent_tags: Set[str]):
            """Helper to collect $ref from a schema object."""
            if "$ref" in schema:
                ref_name = schema["$ref"].split("/")[-1]
                collect_references(ref_name, parent_tags)

            # Check properties (sorted for determinism)
            for prop_name in sorted(schema.get("properties", {}).keys()):
                prop = schema["properties"][prop_name]
                if isinstance(prop, dict):
                    _collect_refs_from_schema(prop, parent_tags)

            # Check items (for arrays)
            items = schema.get("items")
            if isinstance(items, dict):
                _collect_refs_from_schema(items, parent_tags)

            # Check additionalProperties
            additional = schema.get("additionalProperties")
            if isinstance(additional, dict):
                _collect_refs_from_schema(additional, parent_tags)

            # Check compositions
            for comp_key in ["allOf", "oneOf", "anyOf"]:
                if comp_key in schema:
                    for sub_schema in schema[comp_key]:
                        if isinstance(sub_schema, dict):
                            _collect_refs_from_schema(sub_schema, parent_tags)

        self._collect_refs_recursive = _collect_refs_from_schema

        # Collect all referenced schemas starting from response schemas (sorted for determinism)
        for schema_name in sorted(response_schemas):
            tags = schema_to_tags[schema_name]
            collect_references(schema_name, tags)

        # Assign schemas to tags
        for schema_name in sorted(self.schema_map.keys()):
            tags = schema_to_tags.get(schema_name, set())

            if len(tags) == 0:
                # Shared type or not directly referenced - put in common
                tag_schemas.setdefault("common", []).append(schema_name)
            elif len(tags) == 1:
                # Belongs to single tag (convert set to sorted list for determinism)
                tag = sorted(tags)[0]
                tag_schemas.setdefault(tag, []).append(schema_name)
            else:
                # Used by multiple tags → common
                tag_schemas.setdefault("common", []).append(schema_name)

        return tag_schemas

    def _generate_module(self, tag: str, schemas: List[str]) -> str:
        """Generate a single module file."""
        lines = [GENERATED_HEADER]

        # Add imports if needed
        has_hashmap = any(
            self._schema_uses_hashmap(self.schema_map[s])
            for s in schemas
        )

        if has_hashmap:
            lines.append("use std::collections::HashMap;\n")

        # Generate each schema
        for schema_name in sorted(schemas):
            schema = self.schema_map[schema_name]
            code = self._generate_type(schema_name, schema)
            if code:
                lines.append(code)
                lines.append("")  # Blank line between types

        return "\n".join(lines)

    def _schema_uses_hashmap(self, schema: dict) -> bool:
        """Check if a schema uses HashMap anywhere."""
        if schema.get("type") == "object" and schema.get("additionalProperties"):
            if not schema.get("properties"):
                return True

        # Check nested properties
        for prop in schema.get("properties", {}).values():
            if isinstance(prop, dict):
                if self._schema_uses_hashmap(prop):
                    return True

        return False

    def _generate_type(self, name: str, schema: dict) -> Optional[str]:
        """Generate Rust code for a schema."""
        # Skip if already generated
        if name in self.generated_types:
            return None

        self.generated_types.add(name)

        # Determine what kind of type this is
        if "enum" in schema:
            return self._generate_enum(name, schema)
        elif "allOf" in schema:
            return self._generate_allof_struct(name, schema)
        elif "oneOf" in schema or "anyOf" in schema:
            return self._generate_oneof_enum(name, schema)
        elif schema.get("type") == "object" or "properties" in schema:
            return self._generate_struct(name, schema)
        else:
            # Type alias
            rust_type = map_openapi_type_to_rust(schema, name)
            description = schema.get("description", "")
            doc = self._format_doc_comment(description)
            return f"{doc}pub type {to_rust_type_name(name)} = {rust_type};"

    def _generate_struct(self, name: str, schema: dict) -> str:
        """Generate a Rust struct."""
        rust_name = to_rust_type_name(name)
        description = schema.get("description", "")
        properties = schema.get("properties", {})
        required = set(schema.get("required", []))

        lines = []

        # Doc comment
        if description:
            lines.append(self._format_doc_comment(description))

        # Derives
        lines.append("#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]")

        # Struct definition
        lines.append(f"pub struct {rust_name} {{")

        # Fields
        for prop_name, prop_schema in sorted(properties.items()):
            field_name = sanitize_field_name(prop_name)
            is_required = prop_name in required

            # Field doc comment
            field_desc = prop_schema.get("description", "")
            if field_desc:
                lines.append(f"    {self._format_doc_comment(field_desc, indent=4)}")

            # Serde rename if needed
            if field_name != prop_name:
                lines.append(f'    #[serde(rename = "{prop_name}")]')

            # Skip serializing if None
            if not is_required:
                lines.append('    #[serde(skip_serializing_if = "Option::is_none")]')

            # Field type
            field_type = map_openapi_type_to_rust(prop_schema, prop_name, rust_name)
            if not is_required:
                field_type = f"Option<{field_type}>"

            lines.append(f"    pub {field_name}: {field_type},")

        lines.append("}")

        return "\n".join(lines)

    def _generate_enum(self, name: str, schema: dict) -> str:
        """Generate a Rust enum for string/integer enums."""
        rust_name = to_rust_type_name(name)
        description = schema.get("description", "")
        enum_values = schema.get("enum", [])
        enum_type = schema.get("type", "string")

        lines = []

        # Doc comment
        if description:
            lines.append(self._format_doc_comment(description))

        # Derives
        lines.append("#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]")

        # Enum definition
        lines.append(f"pub enum {rust_name} {{")

        # Variants
        for value in enum_values:
            variant_name = to_rust_enum_variant(str(value))

            # Add serde rename for non-matching values
            if enum_type == "string":
                lines.append(f'    #[serde(rename = "{value}")]')
            else:
                # Integer enum - need custom serialization
                lines.append(f'    #[serde(rename = "{value}")]')

            lines.append(f"    {variant_name},")

        lines.append("}")

        return "\n".join(lines)

    def _generate_allof_struct(self, name: str, schema: dict) -> str:
        """Generate a struct from allOf composition."""
        rust_name = to_rust_type_name(name)
        description = schema.get("description", "")
        all_of = schema.get("allOf", [])

        # Merge all properties from allOf schemas
        merged_properties = {}
        merged_required = set()

        for sub_schema in all_of:
            # Resolve $ref if present
            if "$ref" in sub_schema:
                ref_name = sub_schema["$ref"].split("/")[-1]
                sub_schema = self.schema_map.get(ref_name, {})

            # Merge properties
            properties = sub_schema.get("properties", {})
            merged_properties.update(properties)

            # Merge required
            required = sub_schema.get("required", [])
            merged_required.update(required)

        # Create merged schema
        merged_schema = {
            "type": "object",
            "description": description,
            "properties": merged_properties,
            "required": list(merged_required)
        }

        return self._generate_struct(name, merged_schema)

    def _generate_oneof_enum(self, name: str, schema: dict) -> str:
        """Generate an untagged enum for oneOf/anyOf."""
        rust_name = to_rust_type_name(name)
        description = schema.get("description", "")
        one_of = schema.get("oneOf", schema.get("anyOf", []))

        lines = []

        # Doc comment
        if description:
            lines.append(self._format_doc_comment(description))

        # Derives
        lines.append("#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]")
        lines.append("#[serde(untagged)]")

        # Enum definition
        lines.append(f"pub enum {rust_name} {{")

        # Variants
        for i, variant_schema in enumerate(one_of):
            # Try to get a meaningful name
            if "$ref" in variant_schema:
                variant_name = variant_schema["$ref"].split("/")[-1]
                variant_type = to_rust_type_name(variant_name)
            else:
                variant_name = f"Variant{i}"
                variant_type = map_openapi_type_to_rust(variant_schema)

            lines.append(f"    {to_rust_type_name(variant_name)}({variant_type}),")

        lines.append("}")

        return "\n".join(lines)

    def _format_doc_comment(self, text: str, indent: int = 0) -> str:
        """Format a documentation comment."""
        if not text:
            return ""

        indent_str = " " * indent
        lines = text.strip().split("\n")

        if len(lines) == 1:
            return f"{indent_str}/// {lines[0]}"

        result = []
        for line in lines:
            result.append(f"{indent_str}/// {line}")
        return "\n".join(result)

    def _generate_mod_rs(self, module_files: List[str]) -> str:
        """Generate mod.rs file."""
        lines = [GENERATED_HEADER]

        # Extract module names (remove .rs extension, skip mod.rs)
        modules = sorted(
            f.replace(".rs", "")
            for f in module_files
            if f != "mod.rs"
        )

        # Add pub mod declarations
        for module in modules:
            lines.append(f"pub mod {module};")

        return "\n".join(lines) + "\n"


# =============================================================================
# Main Generation Function
# =============================================================================

def generate_models(
    schema_map_path: str,
    spec_map_path: str,
    output_dir: str
) -> None:
    """
    Generate Rust models from OpenAPI schemas.

    Args:
        schema_map_path: Path to schema_map.json
        spec_map_path: Path to spec_map.json
        output_dir: Output directory for generated files
    """
    # Load input files
    with open(schema_map_path, "r", encoding="utf-8") as f:
        schema_map = json.load(f)

    with open(spec_map_path, "r", encoding="utf-8") as f:
        spec_map = json.load(f)

    print(f"  Loaded {len(schema_map)} schemas")
    print(f"  Loaded {len(spec_map)} API tags")

    # Generate code
    generator = RustCodeGenerator(schema_map, spec_map)
    modules = generator.generate_all()

    print(f"  Generated {len(modules)} module files")

    # Write files
    os.makedirs(output_dir, exist_ok=True)

    # Clean existing files first (to remove old generated files)
    for filename in os.listdir(output_dir):
        if filename.endswith(".rs"):
            os.remove(os.path.join(output_dir, filename))

    # Write new files
    for filename, content in sorted(modules.items()):
        file_path = os.path.join(output_dir, filename)
        with open(file_path, "w", encoding="utf-8", newline="\n") as f:
            f.write(content)
        print(f"    Wrote {filename}")

    print(f"  Total Rust types generated: {len(generator.generated_types)}")


if __name__ == "__main__":
    import sys

    if len(sys.argv) < 4:
        print("Usage: generate_models.py <schema_map.json> <spec_map.json> <output_dir>")
        sys.exit(1)

    schema_map_path = sys.argv[1]
    spec_map_path = sys.argv[2]
    output_dir = sys.argv[3]

    generate_models(schema_map_path, spec_map_path, output_dir)
