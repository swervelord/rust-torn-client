// =============================================================================
// AUTO-GENERATED â€” DO NOT EDIT
// =============================================================================
// This module is generated by the regen pipeline (scripts/regen.py).
// Any manual changes will be overwritten on the next regeneration.
//
// To fix issues in generated code, modify the generator configuration or add
// a deterministic patch step. See GENERATED_POLICY.md.
// =============================================================================

#![allow(non_camel_case_types)]

// Cross-module type imports
use crate::generated::common::{FactionId};
use crate::generated::faction::{FactionSelectionName};
use crate::generated::forum::{ForumSelectionName};
use crate::generated::torn::{UserId};

#[derive(Debug, Clone, PartialEq, Eq, serde::Serialize, serde::Deserialize)]
pub enum ApiKeyAccessTypeEnum {
    #[serde(rename = "Custom")]
    Custom,
    #[serde(rename = "Public Only")]
    PublicOnly,
    #[serde(rename = "Minimal Access")]
    MinimalAccess,
    #[serde(rename = "Limited Access")]
    LimitedAccess,
    #[serde(rename = "Full Access")]
    FullAccess,
}

pub type CompanyId = i32;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyInfoAvailableLog {
    pub category_id: LogCategoryId,
    pub log_ids: Vec<LogId>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyInfoResponse {
    pub info: KeyInfoResponse_Info,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyLogResponse {
    pub log: Vec<serde_json::Value>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum KeySelectionName {
    Variant0(String),
    Variant1(String),
}

pub type LogCategoryId = i32;

pub type LogId = i32;

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum MarketSelectionName {
    Variant0(String),
    Variant1(String),
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum RacingSelectionName {
    Variant0(String),
    Variant1(String),
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum TornSelectionName {
    Variant0(String),
    Variant1(String),
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
#[serde(untagged)]
pub enum UserSelectionName {
    Variant0(String),
    Variant1(String),
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyInfoResponse_Info_Access_Log {
    pub available: Vec<KeyInfoAvailableLog>,
        /// Shows if key has custom log permissions enabled.
    pub custom_permissions: bool,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyInfoResponse_Info_Access {
    pub company: bool,
    pub faction: bool,
    pub level: i32,
    pub log: KeyInfoResponse_Info_Access_Log,
    #[serde(rename = "type")]
    pub type_: ApiKeyAccessTypeEnum,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyInfoResponse_Info_Selections {
    pub company: Vec<String>,
    pub faction: Vec<FactionSelectionName>,
    pub forum: Vec<ForumSelectionName>,
    pub key: Vec<KeySelectionName>,
    pub market: Vec<MarketSelectionName>,
    pub property: Vec<String>,
    pub racing: Vec<RacingSelectionName>,
    pub torn: Vec<TornSelectionName>,
    pub user: Vec<UserSelectionName>,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyInfoResponse_Info_User {
        /// Null only if the user is not in a company.
    pub company_id: Option<CompanyId>,
        /// Null only if the user is not in a faction.
    pub faction_id: Option<FactionId>,
    pub id: UserId,
}

#[derive(Debug, Clone, serde::Serialize, serde::Deserialize)]
pub struct KeyInfoResponse_Info {
    pub access: KeyInfoResponse_Info_Access,
    pub selections: KeyInfoResponse_Info_Selections,
    pub user: KeyInfoResponse_Info_User,
}
